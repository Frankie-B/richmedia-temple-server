<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/util/OptionsValidationError.js | @mediamonks/richmedia-temple-server</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="This is the Richmedia Temple, used for creating richmedia units for various vendors."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@mediamonks/richmedia-temple-server"><meta property="twitter:description" content="This is the Richmedia Temple, used for creating richmedia units for various vendors."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/mediamonks/temple"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/util/OptionsValidationError.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Gajus Kuizinas @gajus
*/
&quot;use strict&quot;;

const WebpackError = require(&quot;./WebpackError&quot;);
const webpackOptionsSchema = require(&quot;../schemas/WebpackOptions.json&quot;);

const getSchemaPart = (path, parents, additionalPath) =&gt; {
	parents = parents || 0;
	path = path.split(&quot;/&quot;);
	path = path.slice(0, path.length - parents);
	if (additionalPath) {
		additionalPath = additionalPath.split(&quot;/&quot;);
		path = path.concat(additionalPath);
	}
	let schemaPart = webpackOptionsSchema;
	for (let i = 1; i &lt; path.length; i++) {
		const inner = schemaPart[path[i]];
		if (inner) schemaPart = inner;
	}
	return schemaPart;
};

const getSchemaPartText = (schemaPart, additionalPath) =&gt; {
	if (additionalPath) {
		for (let i = 0; i &lt; additionalPath.length; i++) {
			const inner = schemaPart[additionalPath[i]];
			if (inner) schemaPart = inner;
		}
	}
	while (schemaPart.$ref) {
		schemaPart = getSchemaPart(schemaPart.$ref);
	}
	let schemaText = WebpackOptionsValidationError.formatSchema(schemaPart);
	if (schemaPart.description) {
		schemaText += `\n-&gt; ${schemaPart.description}`;
	}
	return schemaText;
};

const getSchemaPartDescription = schemaPart =&gt; {
	while (schemaPart.$ref) {
		schemaPart = getSchemaPart(schemaPart.$ref);
	}
	if (schemaPart.description) {
		return `\n-&gt; ${schemaPart.description}`;
	}
	return &quot;&quot;;
};

const filterChildren = children =&gt; {
	return children.filter(
		err =&gt;
			err.keyword !== &quot;anyOf&quot; &amp;&amp;
			err.keyword !== &quot;allOf&quot; &amp;&amp;
			err.keyword !== &quot;oneOf&quot;
	);
};

const indent = (str, prefix, firstLine) =&gt; {
	if (firstLine) {
		return prefix + str.replace(/\n(?!$)/g, &quot;\n&quot; + prefix);
	} else {
		return str.replace(/\n(?!$)/g, `\n${prefix}`);
	}
};

class OptionsValidationError extends WebpackError {
	constructor(validationErrors) {
		super();

		this.name = &quot;WebpackOptionsValidationError&quot;;
		this.message =
			&quot;Invalid configuration object. &quot; +
			&quot;Webpack has been initialised using a configuration object that does not match the API schema.\n&quot; +
			validationErrors
				.map(
					err =&gt;
						&quot; - &quot; +
						indent(
							WebpackOptionsValidationError.formatValidationError(err),
							&quot;   &quot;,
							false
						)
				)
				.join(&quot;\n&quot;);
		this.validationErrors = validationErrors;

		Error.captureStackTrace(this, this.constructor);
	}

	static formatSchema(schema, prevSchemas) {
		prevSchemas = prevSchemas || [];

		const formatInnerSchema = (innerSchema, addSelf) =&gt; {
			if (!addSelf) {
				return WebpackOptionsValidationError.formatSchema(
					innerSchema,
					prevSchemas
				);
			}
			if (prevSchemas.includes(innerSchema)) {
				return &quot;(recursive)&quot;;
			}
			return WebpackOptionsValidationError.formatSchema(
				innerSchema,
				prevSchemas.concat(schema)
			);
		};

		if (schema.type === &quot;string&quot;) {
			if (schema.minLength === 1) {
				return &quot;non-empty string&quot;;
			}
			if (schema.minLength &gt; 1) {
				return `string (min length ${schema.minLength})`;
			}
			return &quot;string&quot;;
		}
		if (schema.type === &quot;boolean&quot;) {
			return &quot;boolean&quot;;
		}
		if (schema.type === &quot;number&quot;) {
			return &quot;number&quot;;
		}
		if (schema.type === &quot;object&quot;) {
			if (schema.properties) {
				const required = schema.required || [];
				return `object { ${Object.keys(schema.properties)
					.map(property =&gt; {
						if (!required.includes(property)) return property + &quot;?&quot;;
						return property;
					})
					.concat(schema.additionalProperties ? [&quot;&#x2026;&quot;] : [])
					.join(&quot;, &quot;)} }`;
			}
			if (schema.additionalProperties) {
				return `object { &lt;key&gt;: ${formatInnerSchema(
					schema.additionalProperties
				)} }`;
			}
			return &quot;object&quot;;
		}
		if (schema.type === &quot;array&quot;) {
			return `[${formatInnerSchema(schema.items)}]`;
		}

		switch (schema.instanceof) {
			case &quot;Function&quot;:
				return &quot;function&quot;;
			case &quot;RegExp&quot;:
				return &quot;RegExp&quot;;
		}

		if (schema.$ref) {
			return formatInnerSchema(getSchemaPart(schema.$ref), true);
		}
		if (schema.allOf) {
			return schema.allOf.map(formatInnerSchema).join(&quot; &amp; &quot;);
		}
		if (schema.oneOf) {
			return schema.oneOf.map(formatInnerSchema).join(&quot; | &quot;);
		}
		if (schema.anyOf) {
			return schema.anyOf.map(formatInnerSchema).join(&quot; | &quot;);
		}
		if (schema.enum) {
			return schema.enum.map(item =&gt; JSON.stringify(item)).join(&quot; | &quot;);
		}
		return JSON.stringify(schema, null, 2);
	}

	static formatValidationError(err) {
		const dataPath = `configuration${err.dataPath}`;
		if (err.keyword === &quot;additionalProperties&quot;) {
			const baseMessage = `${dataPath} has an unknown property &apos;${
				err.params.additionalProperty
				}&apos;. These properties are valid:\n${getSchemaPartText(err.parentSchema)}`;
			if (!err.dataPath) {
				switch (err.params.additionalProperty) {
					case &quot;debug&quot;:
						return (
							`${baseMessage}\n` +
							&quot;The &apos;debug&apos; property was removed in webpack 2.0.0.\n&quot; +
							&quot;Loaders should be updated to allow passing this option via loader options in module.rules.\n&quot; +
							&quot;Until loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\n&quot; +
							&quot;plugins: [\n&quot; +
							&quot;  new webpack.LoaderOptionsPlugin({\n&quot; +
							&quot;    debug: true\n&quot; +
							&quot;  })\n&quot; +
							&quot;]&quot;
						);
				}
				return (
					`${baseMessage}\n` +
					&quot;For typos: please correct them.\n&quot; +
					&quot;For loader options: webpack &gt;= v2.0.0 no longer allows custom properties in configuration.\n&quot; +
					&quot;  Loaders should be updated to allow passing options via loader options in module.rules.\n&quot; +
					&quot;  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\n&quot; +
					&quot;  plugins: [\n&quot; +
					&quot;    new webpack.LoaderOptionsPlugin({\n&quot; +
					&quot;      // test: /\\.xxx$/, // may apply this only for some modules\n&quot; +
					&quot;      options: {\n&quot; +
					`        ${err.params.additionalProperty}: &#x2026;\n` +
					&quot;      }\n&quot; +
					&quot;    })\n&quot; +
					&quot;  ]&quot;
				);
			}
			return baseMessage;
		} else if (err.keyword === &quot;oneOf&quot; || err.keyword === &quot;anyOf&quot;) {
			if (err.children &amp;&amp; err.children.length &gt; 0) {
				if (err.schema.length === 1) {
					const lastChild = err.children[err.children.length - 1];
					const remainingChildren = err.children.slice(
						0,
						err.children.length - 1
					);
					return WebpackOptionsValidationError.formatValidationError(
						Object.assign({}, lastChild, {
							children: remainingChildren,
							parentSchema: Object.assign(
								{},
								err.parentSchema,
								lastChild.parentSchema
							)
						})
					);
				}
				return (
					`${dataPath} should be one of these:\n${getSchemaPartText(
						err.parentSchema
					)}\n` +
					`Details:\n${filterChildren(err.children)
						.map(
							err =&gt;
								&quot; * &quot; +
								indent(
									WebpackOptionsValidationError.formatValidationError(err),
									&quot;   &quot;,
									false
								)
						)
						.join(&quot;\n&quot;)}`
				);
			}
			return `${dataPath} should be one of these:\n${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === &quot;enum&quot;) {
			if (
				err.parentSchema &amp;&amp;
				err.parentSchema.enum &amp;&amp;
				err.parentSchema.enum.length === 1
			) {
				return `${dataPath} should be ${getSchemaPartText(err.parentSchema)}`;
			}
			return `${dataPath} should be one of these:\n${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === &quot;allOf&quot;) {
			return `${dataPath} should be:\n${getSchemaPartText(err.parentSchema)}`;
		} else if (err.keyword === &quot;type&quot;) {
			switch (err.params.type) {
				case &quot;object&quot;:
					return `${dataPath} should be an object.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case &quot;string&quot;:
					return `${dataPath} should be a string.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case &quot;boolean&quot;:
					return `${dataPath} should be a boolean.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case &quot;number&quot;:
					return `${dataPath} should be a number.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case &quot;array&quot;:
					return `${dataPath} should be an array:\n${getSchemaPartText(
						err.parentSchema
					)}`;
			}
			return `${dataPath} should be ${err.params.type}:\n${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === &quot;instanceof&quot;) {
			return `${dataPath} should be an instance of ${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === &quot;required&quot;) {
			const missingProperty = err.params.missingProperty.replace(/^\./, &quot;&quot;);
			return `${dataPath} misses the property &apos;${missingProperty}&apos;.\n${getSchemaPartText(
				err.parentSchema,
				[&quot;properties&quot;, missingProperty]
			)}`;
		} else if (err.keyword === &quot;minimum&quot;) {
			return `${dataPath} ${err.message}.${getSchemaPartDescription(
				err.parentSchema
			)}`;
		} else if (err.keyword === &quot;uniqueItems&quot;) {
			return `${dataPath} should not contain the item &apos;${
				err.data[err.params.i]
				}&apos; twice.${getSchemaPartDescription(err.parentSchema)}`;
		} else if (
			err.keyword === &quot;minLength&quot; ||
			err.keyword === &quot;minItems&quot; ||
			err.keyword === &quot;minProperties&quot;
		) {
			if (err.params.limit === 1) {
				return `${dataPath} should not be empty.${getSchemaPartDescription(
					err.parentSchema
				)}`;
			} else {
				return `${dataPath} ${err.message}${getSchemaPartDescription(
					err.parentSchema
				)}`;
			}
		} else if (err.keyword === &quot;absolutePath&quot;) {
			const baseMessage = `${dataPath}: ${
				err.message
				}${getSchemaPartDescription(err.parentSchema)}`;
			if (dataPath === &quot;configuration.output.filename&quot;) {
				return (
					`${baseMessage}\n` +
					&quot;Please use output.path to specify absolute path and output.filename for the file name.&quot;
				);
			}
			return baseMessage;
		} else {
			// eslint-disable-line no-fallthrough
			return `${dataPath} ${err.message} (${JSON.stringify(
				err,
				null,
				2
			)}).\n${getSchemaPartText(err.parentSchema)}`;
		}
	}
}

module.exports = OptionsValidationError;</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
